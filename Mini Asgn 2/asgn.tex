\documentclass{article}

\title{HW1}
\author{Vedha}
\usepackage{amsmath}
\usepackage{makecell}
\usepackage[nohead, nomarginpar, margin=1in, foot=.25in]{geometry}

\begin{document}
\huge
\begin{center}
	\textbf{Mini Assignment 2} \\
	\textbf{Introduction to Polly}
\end{center}
\bigbreak
\large
\textbf{ } \hfill \break
\textbf{Name : Vedha Moorthy S} \hfill \break
\textbf{Roll No : CS16BTECH11040} \hfill \break
This document is generated by \textbf{\LaTeX}. \hfill \break
\normalsize

\section{Polly Architecture}
\hspace{10mm} In simple terms, Polly is a loop optimizer for LLVM. It is designed to work on the emitted LLVM-IR code.
Theoretically, Polly can be run before the 3 phases in the LLVM pipeline.

\begin{center}
 \begin{tabular}{| c | c | c |}
 \hline
 Pipeline Component & Functionality & Using Polly \\ [0.4ex]
 \Xhline{1pt}
 & Early loop unrolling, & Polly-optimized IR is still \\
 Canonicalization & simple Scalar optimizations,  & human-understandable and so, optimizer can \\
 & simplifying IR code & be fine-tuned to give better results but \\
 && inlining optimizations will not be done \\
 \hline
 & Functions are inlined, & Polly generally not used here \\
 Inliner & multiple passes for simplifying & to avoid messing up with Inliner \\
 & code, simple loop optimizations, & functionalities\\
 & loop invariant code motion & \\
 \hline
 & Target-specific optimizations, & Polly runs on canonicalized code \\
 Target & complex IR generation to & which reduces the burden of \\
 Specialization & perform high level optimizations, & multiple passes while optimizing \\
 & vectorization & the complete code (with headers/packages) \\
 \hline
 \end{tabular}
\end{center}
\hfill \break

\section{Polyhedral Compilation}
\hspace{10mm} The underlying idea behind Polly is the use of Mathematical concepts like Integer Polyhedra to 
represent the program in an abstract Mathematical form. Once the equivalent Mathematical representations 
are obtained, a varied set of optimizations can be run on them.
\hfill \break
\hfill \break
These polyhedral representations are advantageous in the sense that they can look at individual 
array elements and single iterations of loops. Consequently, the efficiency of algortihms used here are 
dependent on their structures rather than no of elements in the representation.

\section{SCoPs (Static Control Parts)}
\hspace{10mm} SCoPs are simply the parts of the program that Polly can optimize. They are detected after the
program is canonicalized, by passing over the program parts. After detection, they are translated into 
polyhedral representations, which are used in the later stages of Polly optimization.
\hfill \break
\hfill \break
SCoPs are basically just 2 forms of control flow structures, the if statements and loops. They are detected
by traversing the program tree. SCoP nodes are added to a separate set while the non-SCoP nodes are ignored and
its children are traversed. Neighbouring regions in the SCoPs set are then merged if possible to obtain a final
set of maximal SCoPs.

\break
\section{Dependences}
\hspace{10mm} Dependences can be understood as a relation between program statements based on the order of
accessing different memory locations. Thus, dependence analysis is where we can find out distribution of memory
accesses. This can be used to segregate statements into smaller groups which reference the some particular
memory locations and these groups in turn can be parallelized to run on multiple processors, drastically
improving the program's performance.
\hfill \break
\hfill \break
Dependencies can be divided into 2 categories :
\subsection{Control}
\hspace{10mm} A statement makes a control decision, based on which the following statements may or may not be evaluated.
\subsection{Data}
\hspace{10mm} A statement modifies a memory location which is then accessed by the following statements.
\hfill \break
\hfill \break
Loop Dependence is a simple instance of the explained Dependence, where the data dependency takes prominence, as
frequently the memory accessed in a loop are closely related spatially or logically.

\end{document}
